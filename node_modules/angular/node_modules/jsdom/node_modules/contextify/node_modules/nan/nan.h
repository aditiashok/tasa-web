/**********************************************************************************
 * NAN - Native Abstractions for Node.js
 *
 * Copyright (c) 2014 NAN contributors:
 *   - Rod Vagg <https://github.com/rvagg>
 *   - Benjamin Byholm <https://github.com/kkoopa>
 *   - Trevor Norris <https://github.com/trevnorris>
 *   - Nathan Rajlich <https://github.com/TooTallNate>
 *   - Brett Lawson <https://github.com/brett19>
 *   - Ben Noordhuis <https://github.com/bnoordhuis>
 *
 * MIT +no-false-attribs License <https://github.com/rvagg/nan/blob/master/LICENSE>
 *
 * Version 1.0.0 (current Node unstable: 0.11.13, Node stable: 0.10.28)
 *
 * ChangeLog:
 *  * 1.0.0 May 4 2014
 *    - Heavy API changes for V8 3.25 / Node 0.11.13
 *    - Use cpplint.py
 *    - Removed NanInitPersistent
 *    - Removed NanPersistentToLocal
 *    - Removed NanFromV8String
 *    - Removed NanMakeWeak
 *    - Removed NanNewLocal
 *    - Removed NAN_WEAK_CALLBACK_OBJECT
 *    - Removed NAN_WEAK_CALLBACK_DATA
 *    - Introduce NanNew, replaces NanNewLocal, NanPersistentToLocal, adds many overloaded typed versions
 *    - Introduce NanUndefined, NanNull, NanTrue and NanFalse
 *    - Introduce NanEscapableScope and NanEscapeScope
 *    - Introduce NanMakeWeakPersistent (requires a special callback to work on both old and new node)
 *    - Introduce NanMakeCallback for node::MakeCallback
 *    - Introduce NanSetTemplate
 *    - Introduce NanGetCurrentContext
 *    - Introduce NanCompileScript and NanRunScript
 *    - Introduce NanAdjustExternalMemory
 *    - Introduce NanAddGCEpilogueCallback, NanAddGCPrologueCallback, NanRemoveGCEpilogueCallback, NanRemoveGCPrologueCallback
 *    - Introduce NanGetHeapStatistics
 *    - Rename NanAsyncWorker#SavePersistent() to SaveToPersistent()
 *
 *  * 0.8.0 Jan 9 2014
 *    - NanDispose -> NanDisposePersistent, deprecate NanDispose
 *    - Extract _NAN_*_RETURN_TYPE, pull up NAN_*()
 *
 *  * 0.7.1 Jan 9 2014
 *    - Fixes to work against debug builds of Node
 *    - Safer NanPersistentToLocal (avoid reinterpret_cast)
 *    - Speed up common NanRawString case by only extracting flattened string when necessary
 *
 *  * 0.7.0 Dec 17 2013
 *    - New no-arg form of NanCallback() constructor.
 *    - NanCallback#Call takes Handle rather than Local
 *    - Removed deprecated NanCallback#Run method, use NanCallback#Call instead
 *    - Split off _NAN_*_ARGS_TYPE from _NAN_*_ARGS
 *    - Restore (unofficial) Node 0.6 compatibility at NanCallback#Call()
 *    - Introduce NanRawString() for char* (or appropriate void*) from v8::String
 *      (replacement for NanFromV8String)
 *    - Introduce NanCString() for null-terminated char* from v8::String
 *
 *  * 0.6.0 Nov 21 2013
 *    - Introduce NanNewLocal<T>(v8::Handle<T> value) for use in place of
 *      v8::Local<T>::New(...) since v8 started requiring isolate in Node 0.11.9
 *
 *  * 0.5.2 Nov 16 2013
 *    - Convert SavePersistent and GetFromPersistent in NanAsyncWorker from protected and public
 *
 *  * 0.5.1 Nov 12 2013
 *    - Use node::MakeCallback() instead of direct v8::Function::Call()
 *
 *  * 0.5.0 Nov 11 2013
 *    - Added @TooTallNate as collaborator
 *    - New, much simpler, "include_dirs" for binding.gyp
 *    - Added full range of NAN_INDEX_* macros to match NAN_PROPERTY_* macros
 *
 *  * 0.4.4 Nov 2 2013
 *    - Isolate argument from v8::Persistent::MakeWeak removed for 0.11.8+
 *
 *  * 0.4.3 Nov 2 2013
 *    - Include node_object_wrap.h, removed from node.h for Node 0.11.8.
 *
 *  * 0.4.2 Nov 2 2013
 *    - Handle deprecation of v8::Persistent::Dispose(v8::Isolate* isolate)) for
 *      Node 0.11.8 release.
 *
 *  * 0.4.1 Sep 16 2013
 *    - Added explicit `#include <uv.h>` as it was removed from node.h for v0.11.8
 *
 *  * 0.4.0 Sep 2 2013
 *    - Added NAN_INLINE and NAN_DEPRECATED and made use of them
 *    - Added NanError, NanTypeError and NanRangeError
 *    - Cleaned up code
 *
 *  * 0.3.2 Aug 30 2013
 *    - Fix missing scope declaration in GetFromPersistent() and SaveToPersistent
 *      in NanAsyncWorker
 *
 *  * 0.3.1 Aug 20 2013
 *    - fix "not all control paths return a value" compile warning on some platforms
 *
 *  * 0.3.0 Aug 19 2013
 *    - Made NAN work with NPM
 *    - Lots of fixes to NanFromV8String, pulling in features from new Node core
 *    - Changed node::encoding to Nan::Encoding in NanFromV8String to unify the API
 *    - Added optional error number argument for NanThrowError()
 *    - Added NanInitPersistent()
 *    - Added NanReturnNull() and NanReturnEmptyString()
 *    - Added NanLocker and NanUnlocker
 *    - Added missing scopes
 *    - Made sure to clear disposed Persistent handles
 *    - Changed NanAsyncWorker to allocate error messages on the heap
 *    - Changed NanThrowError(Local<Value>) to NanThrowError(Handle<Value>)
 *    - Fixed leak in NanAsyncWorker when errmsg is used
 *
 *  * 0.2.2 Aug 5 2013
 *    - Fixed usage of undefined variable with node::BASE64 in NanFromV8String()
 *
 *  * 0.2.1 Aug 5 2013
 *    - Fixed 0.8 breakage, node::BUFFER encoding type not available in 0.8 for
 *      NanFromV8String()
 *
 *  * 0.2.0 Aug 5 2013
 *    - Added NAN_PROPERTY_GETTER, NAN_PROPERTY_SETTER, NAN_PROPERTY_ENUMERATOR,
 *      NAN_PROPERTY_DELETER, NAN_PROPERTY_QUERY
 *    - Extracted _NAN_METHOD_ARGS, _NAN_GETTER_ARGS, _NAN_SETTER_ARGS,
 *      _NAN_PROPERTY_GETTER_ARGS, _NAN_PROPERTY_SETTER_ARGS,
 *      _NAN_PROPERTY_ENUMERATOR_ARGS, _NAN_PROPERTY_DELETER_ARGS,
 *      _NAN_PROPERTY_QUERY_ARGS
 *    - Added NanGetInternalFieldPointer, NanSetInternalFieldPointer
 *    - Added NAN_WEAK_CALLBACK, NAN_WEAK_CALLBACK_OBJECT,
 *      NAN_WEAK_CALLBACK_DATA, NanMakeWeak
 *    - Renamed THROW_ERROR to _NAN_THROW_ERROR
 *    - Added NanNewBufferHandle(char*, size_t, node::smalloc::FreeCallback, void*)
 *    - Added NanBufferUse(char*, uint32_t)
 *    - Added NanNewContextHandle(v8::ExtensionConfiguration*,
 *        v8::Handle<v8::ObjectTemplate>, v8::Handle<v8::Value>)
 *    - Fixed broken NanCallback#GetFunction()
 *    - Added optional encoding and size arguments to NanFromV8String()
 *    - Added NanGetPointerSafe() and NanSetPointerSafe()
 *    - Added initial test suite (to be expanded)
 *    - Allow NanUInt32OptionValue to convert any Number object
 *
 *  * 0.1.0 Jul 21 2013
 *    - Added `NAN_GETTER`, `NAN_SETTER`
 *    - Added `NanThrowError` with single Local<Value> argument
 *    - Added `NanNewBufferHandle` with single uint32_t argument
 *    - Added `NanHasInstance(Persistent<FunctionTemplate>&, Handle<Value>)`
 *    - Added `Local<Function> NanCallback#GetFunction()`
 *    - Added `NanCallback#Call(int, Local<Value>[])`
 *    - Deprecated `NanCallback#Run(int, Local<Value>[])` in favour of Call
 *
 * See https://github.com/rvagg/nan for the latest update to this file
 **********************************************************************************/

#ifndef NAN_H_
#define NAN_H_

#include <uv.h>
#include <node.h>
#include <node_buffer.h>
#include <node_version.h>
#include <node_object_wrap.h>
#include <string.h>

#if defined(__GNUC__) && !defined(DEBUG)
# define NAN_INLINE inline __attribute__((always_inline))
#elif defined(_MSC_VER) && !defined(DEBUG)
# define NAN_INLINE __forceinline
#else
# define NAN_INLINE inline
#endif

#if defined(__GNUC__) && !V8_DISABLE_DEPRECATIONS
# define NAN_DEPRECATED __attribute__((deprecated))
#elif defined(_MSC_VER) && !V8_DISABLE_DEPRECATIONS
# define NAN_DEPRECATED __declspec(deprecated)
#else
# define NAN_DEPRECATED
#endif

// some generic helpers

template<typename T> NAN_INLINE bool NanSetPointerSafe(
    T *var
  , T val
) {
  if (var) {
    *var = val;
    return true;
  } else {
    return false;
  }
}

template<typename T> NAN_INLINE T NanGetPointerSafe(
    T *var
  , T fallback = reinterpret_cast<T>(0)
) {
  if (var) {
    return *var;
  } else {
    return fallback;
  }
}

NAN_INLINE bool NanBooleanOptionValue(
    v8::Local<v8::Object> optionsObj
  , v8::Handle<v8::String> opt, bool def
) {
  if (def) {
    return optionsObj.IsEmpty()
      || !optionsObj->Has(opt)
      || optionsObj->Get(opt)->BooleanValue();
  } else {
    return !optionsObj.IsEmpty()
      && optionsObj->Has(opt)
      && optionsObj->Get(opt)->BooleanValue();
  }
}

NAN_INLINE bool NanBooleanOptionValue(
    v8::Local<v8::Object> optionsObj
  , v8::Handle<v8::String> opt
) {
  return NanBooleanOptionValue(optionsObj, opt, false);
}

NAN_INLINE uint32_t NanUInt32OptionValue(
    v8::Local<v8::Object> optionsObj
  , v8::Handle<v8::String> opt
  , uint32_t def
) {
  return !optionsObj.IsEmpty()
    && optionsObj->Has(opt)
    && optionsObj->Get(opt)->IsNumber()
      ? optionsObj->Get(opt)->Uint32Value()
      : def;
}

#if (NODE_MODULE_VERSION > 0x000B)
// Node 0.11+ (0.11.3 and below won't compile with these)

# define _NAN_METHOD_ARGS_TYPE const v8::FunctionCallbackInfo<v8::Value>&
# define _NAN_METHOD_ARGS _NAN_METHOD_ARGS_TYPE args
# define _NAN_METHOD_RETURN_TYPE void

# define _NAN_GETTER_ARGS_TYPE const v8::PropertyCallbackInfo<v8::Value>&
# define _NAN_GETTER_ARGS _NAN_GETTER_ARGS_TYPE args
# define _NAN_GETTER_RETURN_TYPE void

# define _NAN_SETTER_ARGS_TYPE const v8::PropertyCallbackInfo<void>&
# define _NAN_SETTER_ARGS _NAN_SETTER_ARGS_TYPE args
# define _NAN_SETTER_RETURN_TYPE void

# define _NAN_PROPERTY_GETTER_ARGS_TYPE                                        \
    const v8::PropertyCallbackInfo<v8::Value>&
# define _NAN_PROPERTY_GETTER_ARGS _NAN_PROPERTY_GETTER_ARGS_TYPE args
# define _NAN_PROPERTY_GETTER_RETURN_TYPE void

# define _NAN_PROPERTY_SETTER_ARGS_TYPE                                        \
    const v8::PropertyCallbackInfo<v8::Value>&
# define _NAN_PROPERTY_SETTER_ARGS _NAN_PROPERTY_SETTER_ARGS_TYPE args
# define _NAN_PROPERTY_SETTER_RETURN_TYPE void

# define _NAN_PROPERTY_ENUMERATOR_ARGS_TYPE                                    \
    const v8::PropertyCallbackInfo<v8::Array>&
# define _NAN_PROPERTY_ENUMERATOR_ARGS _NAN_PROPERTY_ENUMERATOR_ARGS_TYPE args
# define _NAN_PROPERTY_ENUMERATOR_RETURN_TYPE void

# define _NAN_PROPERTY_DELETER_ARGS_TYPE                                       \
    const v8::PropertyCallbackInfo<v8::Boolean>&
# define _NAN_PROPERTY_DELETER_ARGS                                            \
    _NAN_PROPERTY_DELETER_ARGS_TYPE args
# define _NAN_PROPERTY_DELETER_RETURN_TYPE void

# define _NAN_PROPERTY_QUERY_ARGS_TYPE                                         \
    const v8::PropertyCallbackInfo<v8::Integer>&
# define _NAN_PROPERTY_QUERY_ARGS _NAN_PROPERTY_QUERY_ARGS_TYPE args
# define _NAN_PROPERTY_QUERY_RETURN_TYPE void

# define _NAN_INDEX_GETTER_ARGS_TYPE                                           \
    const v8::PropertyCallbackInfo<v8::Value>&
# define _NAN_INDEX_GETTER_ARGS _NAN_INDEX_GETTER_ARGS_TYPE args
# define _NAN_INDEX_GETTER_RETURN_TYPE void

# define _NAN_INDEX_SETTER_ARGS_TYPE                                           \
    const v8::PropertyCallbackInfo<v8::Value>&
# define _NAN_INDEX_SETTER_ARGS _NAN_INDEX_SETTER_ARGS_TYPE args
# define _NAN_INDEX_SETTER_RETURN_TYPE void

# define _NAN_INDEX_ENUMERATOR_ARGS_TYPE                                       \
    const v8::PropertyCallbackInfo<v8::Array>&
# define _NAN_INDEX_ENUMERATOR_ARGS _NAN_INDEX_ENUMERATOR_ARGS_TYPE args
# define _NAN_INDEX_ENUMERATOR_RETURN_TYPE void

# define _NAN_INDEX_DELETER_ARGS_TYPE                                          \
    const v8::PropertyCallbackInfo<v8::Boolean>&
# define _NAN_INDEX_DELETER_ARGS _NAN_INDEX_DELETER_ARGS_TYPE args
# define _NAN_INDEX_DELETER_RETURN_TYPE void

# define _NAN_INDEX_QUERY_ARGS_TYPE                                            \
    const v8::PropertyCallbackInfo<v8::Integer>&
# define _NAN_INDEX_QUERY_ARGS _NAN_INDEX_QUERY_ARGS_TYPE args
# define _NAN_INDEX_QUERY_RETURN_TYPE void

typedef v8::FunctionCallback NanFunctionCallback;
static v8::Isolate* nan_isolate = v8::Isolate::GetCurrent();

# define NanUndefined() v8::Undefined(nan_isolate)
# define NanNull() v8::Null(nan_isolate)
# define NanTrue() v8::True(nan_isolate)
# define NanFalse() v8::False(nan_isolate)
# define NanAdjustExternalMemory(amount)                                       \
    nan_isolate->AdjustAmountOfExternalAllocatedMemory(amount)
# define NanSetTemplate(templ, name, value) templ->Set(nan_isolate, name, value)
# define NanGetCurrentContext() nan_isolate->GetCurrentContext()
# define NanMakeCallback(target, func, argc, argv)                             \
    node::MakeCallback(nan_isolate, target, func, argc, argv)
# define NanGetInternalFieldPointer(object, index)                             \
    object->GetAlignedPointerFromInternalField(index)
# define NanSetInternalFieldPointer(object, index, value)                      \
    object->SetAlignedPointerInInternalField(index, value)

  template<typename T>
  NAN_INLINE v8::Local<T> NanNew() {
    return T::New(nan_isolate);
  }

  template<typename T, typename P>
  NAN_INLINE v8::Local<T> NanNew(P arg1) {
    return T::New(nan_isolate, arg1);
  }

  template<typename T>
  NAN_INLINE v8::Local<v8::Signature> NanNew(
      v8::Handle<v8::FunctionTemplate> receiver
    , int argc
    , v8::Handle<v8::FunctionTemplate> argv[] = 0) {
    return v8::Signature::New(nan_isolate, receiver, argc, argv);
  }

  template<typename T>
  NAN_INLINE v8::Local<v8::FunctionTemplate> NanNew(
      NanFunctionCallback callback
    , v8::Handle<v8::Value> data = v8::Handle<v8::Value>()
    , v8::Handle<v8::Signature> signature = v8::Handle<v8::Signature>()) {
    return T::New(nan_isolate, callback, data, signature);
  }

  template<typename T>
  NAN_INLINE v8::Local<T> NanNew(v8::Handle<T> arg1) {
    return v8::Local<T>::New(nan_isolate, arg1);
  }

  template<typename T>
  NAN_INLINE v8::Local<T> NanNew(const v8::Persistent<T> &arg1) {
    return v8::Local<T>::New(nan_isolate, arg1);
  }

  template<typename T, typename P>
  NAN_INLINE v8::Local<T> NanNew(P arg1, int arg2) {
    return T::New(nan_isolate, arg1, arg2);
  }

  template<>
  NAN_INLINE v8::Local<v8::Array> NanNew<v8::Array>() {
    return v8::Array::New(nan_isolate);
  }

  template<>
  NAN_INLINE v8::Local<v8::Array> NanNew<v8::Array>(int length) {
    return v8::Array::New(nan_isolate, length);
  }

  template<>
  NAN_INLINE v8::Local<v8::Date> NanNew<v8::Date>(double time) {
    return v8::Date::New(nan_isolate, time).As<v8::Date>();
  }

  template<>
  NAN_INLINE v8::Local<v8::Date> NanNew<v8::Date>(int time) {
    return v8::Date::New(nan_isolate, time).As<v8::Date>();
  }

  typedef v8::UnboundScript NanUnboundScript;
  typedef v8::Script NanBoundScript;

  template<typename T, typename P>
  NAN_INLINE v8::Local<T> NanNew(
      P s
    , const v8::ScriptOrigin& origin
  ) {
    v8::ScriptCompiler::Source source(s, origin);
    return v8::ScriptCompiler::CompileUnbound(nan_isolate, &source);
  }

  template<>
  NAN_INLINE v8::Local<NanUnboundScript> NanNew<NanUnboundScript>(
      v8::Local<v8::String> s
  ) {
    v8::ScriptCompiler::Source source(s);
    return v8::ScriptCompiler::CompileUnbound(nan_isolate, &source);
  }

  NAN_INLINE v8::Local<v8::String> NanNew(
      v8::String::ExternalStringResource *resource) {
    return v8::String::NewExternal(nan_isolate, resource);
  }

  NAN_INLINE v8::Local<v8::String> NanNew(
      v8::String::ExternalAsciiStringResource *resource) {
    return v8::String::NewExternal(nan_isolate, resource);
  }

  template<>
  NAN_INLINE v8::Local<v8::BooleanObject> NanNew(bool value) {
    return v8::BooleanObject::New(value).As<v8::BooleanObject>();
  }

  template<>
  NAN_INLINE v8::Local<v8::StringObject>
  NanNew<v8::StringObject, v8::Local<v8::String> >(
      v8::Local<v8::String> value) {
    return v8::StringObject::New(value).As<v8::StringObject>();
  }

  template<>
  NAN_INLINE v8::Local<v8::StringObject>
  NanNew<v8::StringObject, v8::Handle<v8::String> >(
      v8::Handle<v8::String> value) {
    return v8::StringObject::New(value).As<v8::StringObject>();
  }

  template<>
  NAN_INLINE v8::Local<v8::NumberObject> NanNew<v8::NumberObject>(double val) {
    return v8::NumberObject::New(nan_isolate, val).As<v8::NumberObject>();
  }

  template<typename T>
  NAN_INLINE v8::Local<v8::RegExp> NanNew(
      v8::Handle<v8::String> pattern, v8::RegExp::Flags flags) {
    return v8::RegExp::New(pattern, flags);
  }

  template<typename T>
  NAN_INLINE v8::Local<v8::RegExp> NanNew(
      v8::Local<v8::String> pattern, v8::RegExp::Flags flags) {
    return v8::RegExp::New(pattern, flags);
  }

  template<typename T, typename P>
  NAN_INLINE v8::Local<v8::RegExp> NanNew(
      v8::Handle<v8::String> pattern, v8::RegExp::Flags flags) {
    return v8::RegExp::New(pattern, flags);
  }

  template<typename T, typename P>
  NAN_INLINE v8::Local<v8::RegExp> NanNew(
      v8::Local<v8::String> pattern, v8::RegExp::Flags flags) {
    return v8::RegExp::New(pattern, flags);
  }

  template<>
  NAN_INLINE v8::Local<v8::Uint32> NanNew<v8::Uint32, int32_t>(int32_t val) {
    return v8::Uint32::NewFromUnsigned(nan_isolate, val)->ToUint32();
  }

  template<>
  NAN_INLINE v8::Local<v8::Uint32> NanNew<v8::Uint32, uint32_t>(uint32_t val) {
    return v8::Uint32::NewFromUnsigned(nan_isolate, val)->ToUint32();
  }

  template<>
  NAN_INLINE v8::Local<v8::Int32> NanNew<v8::Int32, int32_t>(int32_t val) {
    return v8::Int32::New(nan_isolate, val)->ToInt32();
  }

  template<>
  NAN_INLINE v8::Local<v8::Int32> NanNew<v8::Int32, uint32_t>(uint32_t val) {
    return v8::Int32::New(nan_isolate, val)->ToInt32();
  }

  template<>
  NAN_INLINE v8::Local<v8::String> NanNew<v8::String, char *>(
      char *arg
    , int length) {
    return v8::String::NewFromUtf8(
        nan_isolate
      , arg
      , v8::String::kNormalString
      , length);
  }

  template<>
  NAN_INLINE v8::Local<v8::String> NanNew<v8::String, const char *>(
      const char *arg
    , int length) {
    return v8::String::NewFromUtf8(
        nan_isolate
      , arg
      , v8::String::kNormalString
      , length);
  }

  template<>
  NAN_INLINE v8::Local<v8::String> NanNew<v8::String, char *>(char *arg) {
    return v8::String::NewFromUtf8(nan_isolate, arg);
  }

  template<>
  NAN_INLINE v8::Local<v8::String> NanNew<v8::String, const char *>(
      const char *arg) {
    return v8::String::NewFromUtf8(nan_isolate, arg);
  }

  template<>
  NAN_INLINE v8::Local<v8::String> NanNew<v8::String, uint8_t *>(
      uint8_t *arg
    , int length) {
    return v8::String::NewFromOneByte(
        nan_isolate
      , arg
      , v8::String::kNormalString
      , length);
  }

  template<>
  NAN_INLINE v8::Local<v8::String> NanNew<v8::String, const uint8_t *>(
      const uint8_t *arg
    , int length) {
    return v8::String::NewFromOneByte(
        nan_isolate
      , arg
      , v8::String::kNormalString
      , length);
  }

  template<>
  NAN_INLINE v8::Local<v8::String> NanNew<v8::String, uint8_t *>(uint8_t *arg) {
    return v8::String::NewFromOneByte(nan_isolate, arg);
  }

  template<>
  NAN_INLINE v8::Local<v8::String> NanNew<v8::String, const uint8_t *>(
      const uint8_t *arg) {
    return v8::String::NewFromOneByte(nan_isolate, arg);
  }

  template<>
  NAN_INLINE v8::Local<v8::String> NanNew<v8::String, uint16_t *>(
      uint16_t *arg
    , int length) {
    return v8::String::NewFromTwoByte(
        nan_isolate
      , arg
      , v8::String::kNormalString
      , length);
  }

  template<>
  NAN_INLINE v8::Local<v8::String> NanNew<v8::String, const uint16_t *>(
      const uint16_t *arg
    , int length) {
    return v8::String::NewFromTwoByte(
        nan_isolate
      , arg
      , v8::String::kNormalString
      , length);
  }
  template<>
  NAN_INLINE v8::Local<v8::String> NanNew<v8::String, uint16_t *>(
      uint16_t *arg) {
    return v8::String::NewFromTwoByte(nan_isolate, arg);
  }

  template<>
  NAN_INLINE v8::Local<v8::String> NanNew<v8::String, const uint16_t *>(
      const uint16_t *arg) {
    return v8::String::NewFromTwoByte(nan_isolate, arg);
  }

  template<>
  NAN_INLINE v8::Local<v8::String> NanNew<v8::String>() {
    return v8::String::Empty(nan_isolate);
  }

  NAN_INLINE void NanAddGCEpilogueCallback(
      v8::Isolate::GCEpilogueCallback callback
    , v8::GCType gc_type_filter = v8::kGCTypeAll) {
    nan_isolate->AddGCEpilogueCallback(callback, gc_type_filter);
  }

  NAN_INLINE void NanRemoveGCEpilogueCallback(
      v8::Isolate::GCEpilogueCallback callback) {
    nan_isolate->RemoveGCEpilogueCallback(callback);
  }

  NAN_INLINE void NanAddGCPrologueCallback(
      v8::Isolate::GCPrologueCallback callback
    , v8::GCType gc_type_filter = v8::kGCTypeAll) {
    nan_isolate->AddGCPrologueCallback(callback, gc_type_filter);
  }

  NAN_INLINE void NanRemoveGCPrologueCallback(
      v8::Isolate::GCPrologueCallback callback) {
    nan_isolate->RemoveGCPrologueCallback(callback);
  }

  NAN_INLINE void NanGetHeapStatistics(
      v8::HeapStatistics *heap_statistics) {
    nan_isolate->GetHeapStatistics(heap_statistics);
  }

# define NanSymbol(value) NanNew<v8::String>(value)

  template<typename T>
  NAN_INLINE void NanAssignPersistent(
      v8::Persistent<T>& handle
    , v8::Handle<T> obj) {
      handle.Reset(nan_isolate, obj);
  }

  template<typename T>
  NAN_INLINE void NanAssignPersistent(
      v8::Persistent<T>& handle
    , const v8::Persistent<T>& obj) {
      handle.Reset(nan_isolate, obj);
  }

  template<typename T, typename P>
  struct _NanWeakCallbackInfo {
    typedef void (*Callback)(
      const v8::WeakCallbackData<T, _NanWeakCallbackInfo<T, P> >& data);
    _NanWeakCallbackInfo(v8::Handle<T> handle, P* param, Callback cb)
      : parameter(param), callback(cb) {
       NanAssignPersistent(persistent, handle);
    }

    ~_NanWeakCallbackInfo() {
      persistent.Reset();
    }

    P* const parameter;
    Callback const callback;
    v8::Persistent<T> persistent;
  };

  template<typename T, typename P>
  class _NanWeakCallbackData {
   public:
    _NanWeakCallbackData(_NanWeakCallbackInfo<T, P> *info)
      : info_(info) { }

    NAN_INLINE v8::Local<T> GetValue() const {
      return NanNew(info_->persistent);
    }
    NAN_INLINE P* GetParameter() const { return info_->parameter; }
    NAN_INLINE void Revive() const {
      info_->persistent.SetWeak(info_, info_->callback);
    }

    NAN_INLINE void Dispose() const {
      delete info_;
    }

   private:
    _NanWeakCallbackInfo<T, P>* info_;
  };

// do not use for declaration
# define NAN_WEAK_CALLBACK(name)                                               \
    template<typename T, typename P>                                           \
    static void name(                                                          \
      const v8::WeakCallbackData<T, _NanWeakCallbackInfo<T, P> > &data) {      \
        _NanWeakCallbackData<T, P> wcbd(                                       \
           data.GetParameter());                                               \
        _Nan_Weak_Callback_ ## name(wcbd);                                     \
    }                                                                          \
                                                                               \
    template<typename T, typename P>                                           \
    NAN_INLINE void _Nan_Weak_Callback_ ## name(                               \
        const _NanWeakCallbackData<T, P> &data)

# define NanScope() v8::HandleScope scope(nan_isolate)
# define NanEscapableScope() v8::EscapableHandleScope scope(nan_isolate)
# define NanEscapeScope(val) scope.Escape(val)
# define NanLocker() v8::Locker locker(nan_isolate)
# define NanUnlocker() v8::Unlocker unlocker(nan_isolate)
# define NanReturnValue(value) return args.GetReturnValue().Set(value)
# define NanReturnUndefined() return
# define NanReturnNull() return args.GetReturnValue().SetNull()
# define NanReturnEmptyString() return args.GetReturnValue().SetEmptyString()

# define NanObjectWrapHandle(obj) obj->handle()

template<typename T, typename P>
void NAN_INLINE NanMakeWeakPersistent(
    v8::Handle<T> handle
  , P* parameter
  , typename _NanWeakCallbackInfo<T, P>::Callback callback) {
    _NanWeakCallbackInfo<T, P> *cbinfo =
     new _NanWeakCallbackInfo<T, P>(handle, parameter, callback);
    cbinfo->persistent.SetWeak(cbinfo, callback);
}

# define _NAN_ERROR(fun, errmsg) fun(NanNew<v8::String>(errmsg))

# define _NAN_THROW_ERROR(fun, errmsg)                                         \
    do {                                                                       \
      NanScope();   